what is hash ??? 

-> which provide always unique object id every object 

===============================
why we use hash ? 

using of list search it goes one by one (O(n))

hash searching jump directly to when it should be O(1)

===========================================================
Hashable vs Unhashable

Not everything in Python can be hashed.

print(hash(42))        # works
print(hash("world"))   # works

# Unhashable examples (mutable)
print(hash([1,2,3]))   # âŒ TypeError
print(hash({1:2}))     # âŒ TypeError
============================================================
Step 3: Hash in Dictionary (Real Use)

Dictionaries use hash internally.

students = {"roll101": "Anjali", "roll102": "Dhruvil"}

print("roll101" in students)     # True
print(students["roll101"])       # "Anjali"

# behind the scenes
print(hash("roll101"))           # Python uses this hash to store

================================================================
What is a Collision in Hashing?

When we use hashing, we store data in a hash table using a hash function.

The hash function takes a key â†’ computes an index â†’ stores the value in that index.

Collision occurs when two different keys generate the same index.

ğŸ‘‰ Example:
Suppose our hash table size is 5, and we insert keys with this hash function:

index = key % 5


Key 10 â†’ 10 % 5 = 0

Key 15 â†’ 15 % 5 = 0

Here, 10 and 15 both map to index 0 â†’ collision!

ğŸ”¹ Why Collisions Happen?

Limited table size (e.g., only 5 slots, but more than 5 keys).

Hash function overlap (different inputs give same output).

Poor hash function (not spreading keys uniformly).

ğŸ”¹ How to Handle Collisions? (Collision Resolution Techniques)

There are 2 main categories:

1. Open Hashing (Chaining)

Each index in the hash table stores a linked list (or list in Python).

If multiple keys hash to the same index â†’ store them in the list at that index.

ğŸ‘‰ Example in Python:

class HashTable:
    def __init__(self, size):
        self.size = size
        self.table = [[] for _ in range(size)]  # list of lists (chaining)

    def insert(self, key, value):
        index = key % self.size
        self.table[index].append((key, value))

    def display(self):
        for i in range(self.size):
            print(i, ":", self.table[i])


ht = HashTable(5)
ht.insert(10, "A")
ht.insert(15, "B")  # collision with 10
ht.insert(20, "C")  # collision with 10, 15
ht.insert(7, "D")

ht.display()


ğŸ“Œ Output:

0 : [(10, 'A'), (15, 'B'), (20, 'C')]
1 : []
2 : []
3 : []
4 : [(7, 'D')]


Here, 10, 15, and 20 collided but stored in a list at index 0.
============================================================
Open Addressing

If a slot is full, find another slot using a probing technique:

Linear Probing â†’ check next empty slot.

Quadratic Probing â†’ check slots with increasing quadratic steps.

Double Hashing â†’ use another hash function to find new slot.

ğŸ‘‰ Example: Linear Probing

class HashTableLP:
    def __init__(self, size):
        self.size = size
        self.table = [None] * size

    def insert(self, key, value):
        index = key % self.size
        while self.table[index] is not None:
            index = (index + 1) % self.size  # linear probing
        self.table[index] = (key, value)

    def display(self):
        for i, val in enumerate(self.table):
            print(i, ":", val)


ht = HashTableLP(5)
ht.insert(10, "A")
ht.insert(15, "B")  # collision
ht.insert(20, "C")  # another collision
ht.insert(7, "D")

ht.display()


ğŸ“Œ Output:

0 : (10, 'A')
1 : (15, 'B')
2 : (20, 'C')
3 : (7, 'D')
4 : None


âœ… Summary:

Collision happens when two keys map to the same index.

We fix it using:

Chaining (linked list at each index)

Open Addressing (probing for next slot)

==================================================================
magine Your Classroom Lockers

You have 100 lockers in your classroom.

Each student gets a roll number.
Example: Anjali â†’ 101, Dhruvil â†’ 102, Krisha â†’ 103

Now, how do we decide which locker belongs to whom?

ğŸ‘‰ We use a rule (hash function):

locker_number = roll_number % 100


Roll 101 â†’ Locker 1

Roll 102 â†’ Locker 2

Roll 103 â†’ Locker 3

So every student knows directly which locker is theirs â†’ they donâ€™t need to search all 100 lockers.

ğŸ’¡ That is a Hash Table!

Locker room (array) â†’ is the hash table

Roll number â†’ is the key

Studentâ€™s name inside locker â†’ is the value

Rule (modulus) â†’ is the hash function

ğŸš¨ What if 2 students get same locker?

Example:

Roll 115 â†’ 15

Roll 215 â†’ also 15

Both want locker 15 â†’ this is called a collision.
Solutions:

Keep a list inside locker (so both fit in one locker) â†’ chaining

Or move one to the next empty locker â†’ open addressing

âš¡ Why Hash Table is Powerful?

Normally searching a student in 100 lockers = O(n) (check each locker).

With hash table â†’ O(1), because roll number â†’ directly tells locker.

Python Example (same story)
# Dictionary is a hash table
students = {
    101: "Anjali",
    102: "Dhruvil",
    103: "Krisha"
}

print(students[101])   # Anjali  (direct locker access!)
print(students[102])   # Dhruvil


ğŸ‘‰ In one line:
A hash table is like a locker room where a formula decides exactly which locker your stuff goes into â†’ so you can find it instantly.